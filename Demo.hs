--------------------------------------------------------
--    __ __         __       ____  ___                --
--   / // /__ ____ / /_____ / / / / _ \___ __ _  ___  --
--  / _  / _ `(_-</  '_/ -_) / / / // / -_)  ' \/ _ \ --
-- /_//_/\_,_/___/_/\_\\__/_/_/ /____/\__/_/_/_/\___/ --
--------------------------------------------------------

-- Это демо модуль на языке Haskell, в котором показаны основные особенности возможности языка.
--
-- Материал берется в основном отсюда:
-- http://wiki.nsunc.com/_export/html/haskell
-- и отсюда:
-- https://stepik.org/course/75/

-------------------------------------------------------------------------------
-- Полезные команды оболочки ghci
-------------------------------------------------------------------------------

-- :q, :quit     - выйти
-- :l, :load     - загрузить программу
-- :r, :reload   - перезагрузить текущий модуль
-- :t, :type     - напечатать сигнатуру функции
-- :i, :info     - напечатать сигнатуру функции и указать, в каком файле функция была определена
-- :?, :h, :help - help

{-

let используется, чтобы определять новые функции:

> let {f :: Int -> Int; f n = n * 2}

> :{
| let f :: Int -> Int
|     f n = n * 2
> :}

-}
-------------------------------------------------------------------------------
-- Модули
-------------------------------------------------------------------------------
-- Это название модуля, определяемого в данном файле
module Demo where

-- Импортирование других модулей
import Data.List                     -- полностью
import Data.Char (toUpper, toLower)  -- только некоторые функции
import Data.Data hiding (gunfold)    -- кроме заданных
import qualified Data.List           -- для всех функций из этого модуля должны использоваться полные имена
import qualified Data.Set as Set     -- импорт с назначением псевдонима

-------------------------------------------------------------------------------
-- Определение функций
-------------------------------------------------------------------------------
-- У функции может быть явно задана сигнатура, но это не обязательно.
fact :: Integer -> Integer
-- Шаблонное определение функции
fact 0 = 1
fact n = n * fact (n-1)

-- или через гарды
fact' 0 = 1
fact' x | x <= 1    = 1
        | otherwise = x * fact' (x-1)

sign 0 = 0
sign x | x > 0     = 1
       | otherwise = (-1)

-------------------------------------------------------------------------------
-- Ветвления
-------------------------------------------------------------------------------
nosign x = if x >= 0 then x else negate x

sign'' x = if x >= 0
           then (if x == 0 then 0 else 1)
           else -1

casing x y = case (x, y) of
            (_, 0) -> x
            (_, n) -> 1 + casing x (n-1)

-------------------------------------------------------------------------------
-- Частичное применение функций, каррирование
-------------------------------------------------------------------------------
add x y = x + y

-- Частичное применение
inc = add 1

-- Каррирование.
-- fst принимает двухэлементный кортеж,
-- curry fst принимает уже 2 аргумента.

-- uncarry выполняет ровно обратное действие.
-------------------------------------------------------------------------------
-- Лямбды
-------------------------------------------------------------------------------
inc' = (\x y -> x + y) 1
add' = \x y -> x + y

-------------------------------------------------------------------------------
-- Префиксный и постфиксный стиль
-------------------------------------------------------------------------------
-- Функции можно вызывать как в префиксном так и в постфиксном стилях
max1 = max 10 28
max2 = 10 `max` 28

-- И опраторы можно вызывать как в префиксном так и в постфиксном стилях
sum1 = 10 + 28
sum2 = (+) 10 28
-- единственное исколючение - унарным минус
-- (-) 10 - это частично применненный бинарный оператор вычитания
-- (-10) - а это число -10

-------------------------------------------------------------------------------
-- Операторы
-------------------------------------------------------------------------------
-- Чтобы определять операторы, можно использовать следующие символы:
-- ! # $ % & * + . / < = > ? @ \ ^ | - ~ :
-- Но нельзя начинать имя оператора с символа :

-- Орератор сумма квадратов
infixl 6 *+*
a *+* b = a ^ 2 + b ^ 2
-- можно было определить и префиксно:
-- (*+*) a b = a ^ 2 + b ^ 2

-- Для частичного применения операторов есть специальный синтаксис (сечения)
twoDivBy = (2 /)
divByTwo = (/ 2)

-------------------------------------------------------------------------------
-- Левая и правая ассициативность операторов
-------------------------------------------------------------------------------
-- Из стандартной библиотеки:
-- infixr 8 ^, `logBase`
-- infixl 7 *, /, `div`, `mod`
-- infixl 6 +, -
-- infix 4 ==, /=, >, >=, <, <=

-- Если приоритет и ассоциативность оператора не заданы, то haskell преполагает,
-- что он имеет левую ассоциативность (infixl) и его приориет равен 9

-------------------------------------------------------------------------------
-- Оператор $
-------------------------------------------------------------------------------
-- По сути этот оператор ничего не делает:
infixr 0 &
f & x = f x
-- но, имея приоритет 0, он позволяет избежать избыточного применения скобок:
-- sin (pi / 2)
-- sin $ pi / 2

-------------------------------------------------------------------------------
-- Базовые типы в haskell
-------------------------------------------------------------------------------
-- Char
-- Bool
-- Int - целые ограниченного размера
-- Integer - целые произвольного размера
-- Float
-- Double


-- Кортежи
cort = (2, True)
cort' = (,) True 3
cort3 = (,,) 1 'a' True

-- fst возвращает первый элемент двухэлементного кортежа
cort1 = fst cort
-- snd возвращает второй элемент двухэлементного кортежа
cort2 = snd cort

-- или пустой кортеж
emptyCort = ()


-- Списки
list1 = [1, 2, 3]
list2 = [True, False, False]
-- список типа Char:
str1 = "hello"

-- : - оператор добавления элемента в голову списка
str2 = 'W' : "elcome"

-- (++) - оператор конкатенации списков
str3 = "Wel" ++ "come";

-------------------------------------------------------------------------------
-- error и undefined
-------------------------------------------------------------------------------
-- error "Message" - прерывает выполнение программы и выводит сообщение "Message"
-- undefined - прерывает выполнение программы и выводит стандартное сообщение об ошибке

fact'' 0 = 1
fact'' n = if n < 0 then undefined else n * fact (n-1)

-------------------------------------------------------------------------------
-- Конструкции let-in и where
-------------------------------------------------------------------------------
squareRoots a b c =
    let
        x1 = (-b - sqrtD) / (2 * a)
        x2 = (-b + sqrtD) / (2 * a)
        d = b^2 - 4 * a * c
        sqrtD = sqrt (d)
    in (x1, x2)

squareRoots' a b c = (x1, x2) where
    x1 = (-b - sqrtD) / (2 * a)
    x2 = (-b + sqrtD) / (2 * a)
    d = b^2 - 4 * a * c
    sqrtD = sqrt (d)

dist :: (Double, Double) -> (Double, Double) -> Double
dist p1 p2 = sqrt $ (x1 - x2) ^ 2 + (y1 - y2) ^ 2
    where
        x1 = fst p1
        x2 = fst p2
        y1 = snd p1
        y2 = snd p2

-------------------------------------------------------------------------------
-- Использование вспомогательных функций (пример)
-------------------------------------------------------------------------------
fact''' n | n >= 0 = accumulate 1 n
          | otherwise = error "Argument of factorial can not be negative"
    where
        accumulate acc 0 = acc
        accumulate acc n = accumulate (acc * n) (n-1)

-------------------------------------------------------------------------------
-- Определения некоторых стандартных функций
-------------------------------------------------------------------------------
-- id x = x
-- const x y = x
-- flip f y x = f x y
-- f . g = \x -> f (g x)

-------------------------------------------------------------------------------
-- Классы типов
-------------------------------------------------------------------------------
-- Класс типов, для которых определен оператор не равно.
-- Запись (Eq a => MP a) по сути означает, что класс типов MP расширяет класс типов Eq.
class Eq a => MP a where
    (*+) :: a -> a -> a

    x *+ y = if x == y then x else y  -- можно определять методы по-умолчанию

-- Представители класса типа MP:
instance MP Bool where
    x *+ False = False
    _ *+ _ = True   -- символ _ означает "во всех остальных случаях"

instance (MP a, MP b) => MP (a,b) where
    p1 *+ p2 = (fst p1 *+ fst p2, snd p1 *+ snd p2)

-- Зацикленный энум (пример)
class (Eq a, Enum a, Bounded a) => SafeEnum a where
    ssucc :: a -> a
    ssucc x | x == maxBound = minBound
            | otherwise = succ x

    spred :: a -> a
    spred x | x == minBound = maxBound
            | otherwise = pred x

-------------------------------------------------------------------------------
-- show и read
-------------------------------------------------------------------------------
-- show преобразует объект, относящийся к классу типов Snow, в строку
str_123 = show 123
-- read выполняет обратную операцию
num_123 = read "123" :: Integer
-- в случае неуспеха, read выдает исключение.

-- Есть еще одна функция: reads. Она возвращает список. Если парсинг неудачен, то список будет пустым.
reads_2girls = reads "2 girls" :: [(Int, String)]

-------------------------------------------------------------------------------
-- Форсированные вычиления
-------------------------------------------------------------------------------
{-
seq :: a -> b -> b
seq | b = |         -- если первый агрумент расходится, то функция должна расходиться
seq a b = b         -- в остальных случаях возвращается второй аргумент
-}

-- seq форсирует вычислени своего первого аргумента до слабой заголовочной нормально формы

trySeq1 = seq undefined 2
-- вернет расходящееся вычисление.

trySeq2 = seq (undefined, undefined) 2
-- вычислет первый аргумент до слабой заголовочной нормальной формы (в данном случае она будет
-- совпадать с (undefined, unfedined)) и вернет второй аргумет.

-- Так в функции quux seq позволяет сразу раскрывать длинные цепочки выди ((((n - 1) - 1) - 1) ... - 1)
quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-- Строгий оператор применения (аппликация с вызовом по значению)
{-
($!) :: (a -> b) -> a -> b
f $! x = x 'seq' f x         -- x, вычисленный заранее, используется при подстановке его в функию f
-}

trySeq3 = const 1 $ undefined  -- undefined не вычисляется, вычисления не расходятся
trySeq4 = const 1 $! undefined -- undefined вычисляется, вычисления расходятся

-- Факториал без накапливающихся вычислений (пример)
fact'''' n | n >= 0 = accumulate 1 n
           | otherwise = error "Argument of factorial can not be negative"
    where
        accumulate acc 0 = acc
        accumulate acc n = (accumulate $! (acc * n)) (n-1)

-------------------------------------------------------------------------------
-- Списки
-------------------------------------------------------------------------------
-- Создание пустого списка
emptyList = []
-- Добавление элемента в начало списка
list3 = 3 : []
-- head возвращает первый элемент списка
exampleHead = head [1, 2, 3]
-- tail возвращает вес список без первого элемента
exampleTail = tail [1, 2, 3]

-- Длина списка
{-
length :: [a] -> Int
length []     = 0
length (x:xs) = 1 + length(xs)
-}

-- Конкатенация двух списков
{-
(++) :: [a] -> [a] -> [a]
[] ++ ys     = ys
(x:xs) ++ ys = x : xs ++ ys
-}

-- Функция, проверяющая, является ли список пустым
{-
null :: [a] -> Bool
null [] = True
null _  = False
-}

-- Функция, возвращающая список нечетных чисел из заданного списка (пример)
oddsOnly :: Integral a => [a] -> [a]
oddsOnly [] = []
oddsOnly (x:xs) | odd x = x : oddsOnly xs
                | otherwise = oddsOnly xs

-- Последний элемент списка
{-
last :: [a] -> a
last (x:[])  = x
last (_, xs) = last xs
-}

-- Список без последнего элемента
{-
init [a] -> [a]
init [x] = []
init (x:xs) = x : init xs
-}

-- Обращение списка
{-
reverse :: [a] -> [a]
reverse l = rev l [] where
    rev []     a = a
    rev (x:xs) a = rev xs (x:a)
-}

-- Упаковка двух списков в список из пар
{-
zip :: [a] -> [b] -> [(a,b)]
zip []      _      = []
zip as      []     = []
zip (a:as) (b:bs) = (a,b) : zip as bs
-}

-- Упаковка трех списков в список из троек
{-
zip3 :: [a] -> [b] -> [c] -> [(a,b,c)]
zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
zip3 _      _      _      = []
-}

-- Распаковка списка из пар в два списка
{-
unzip :: [(a,b)] -> ([a], [b])
unzip []        = ([], [])
unzip ((x,y):xys) =
    let (xs,ys) = unzip xys
    in (x:xs, y:ys)
-}

-- Взять первые n элементов списка
{-
take :: Int -> [a] -> [a]
take n _   | n <= 0 = []
take _ []           = []
take n (x:xs)       = x : take (n-1) xs
-}

-- Пропустить первые n элементов списка
{-
drop :: Int -> [a] -> [a]
drop n xs      | n <= 0 = xs
drop _ []               = []
drop n (_:xs)           = drop (n-1) xs
-}

-- Разделить список на два подсписка
{-
splitAt :: Int -> [a] -> ([a],[a])
splitAt n xs = (take n xs, drop n xs)
-}

-- Обращение к элементу списка по номеру
{-
xs     !! n | n < 0 = error "NegativeIndex"
[]     !! _ = error "Index too large"
(x:_)  !! 0 = x
(_:xs) !! n = xs !! (n-1)
-}


-- filter
{-
filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs)
  | p x       = x : filter p xs
  | otherwise = filter p xs
-}

-- takeWhile
{-
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile p (x:xs)
   | p x       = x :takeWhile p xs
   | otherwise = []
-}

-- dropWhile
{-
dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile _ [] = []
dropWhile p xs@(x:xs')            - @ это симсол синонима (псевдонима)
   | p x       = dropWhile p xs'
   | otherwise = xs
-}

-- span
{-
span :: (a -> Bool) -> [a] -> ([a],[a])
span p xs = (takeWhile p xs, dropWhile p xs)
-}

-- break
{-
break :: (a -> Bool) -> [a] -> ([a],[a])
break p = span (not . p)
-}

-- map
{-
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs
-}

-- concat
{-
concat :: [[a]] -> [a]
concat []       = []
concat (xs:xss) = xs ++ concat xss
-}

-- concatMap
{-
concatMap :: (a -> [b]) -> [a] -> [b]
concatMap f xs = concat . map f xs
-}

-- all
{-
all :: (a -> Bool) -> [a] -> Bool
all p = and . map p
-}

-- any
{-
any :: (a -> Bool) -> [a] -> Bool
any p = or . map p
-}

-- zipWith
{-
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith _ []     _      = []
zipWith _ _      []     = []
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
-}

-------------------------------------------------------------------------------
-- Генераторы списков
-------------------------------------------------------------------------------
-- Бесконечный список единиц
ones = 1 : ones

-- Возрастающие числа
nats n = n : nats (n+1)

-- Бесконечный список квадратов натуральных чисел
squareNats = map (^ 2) $ nats 1

-- Набор чисел Фибоначчи (пример)
fibStream = 0 : 1 : zipWith (+) fibStream (tail fibStream)

-- repeat
{-
repeat :: a -> [a]
repeat x = xs where xs = x : xs
-}

-- replicate
{-
replicate :: Int -> a -> [a]
replicate n x = take n (repeat x)
-}

-- cycle
{-
cycle :: [a] -> [a]
cycle [] = error "cycle: empty list"
cycle xs = ys where ys = xs ++ ys
-}

-- iterate
{-
iterate :: (a -> a) -> a -> [a]
iterate f x = x : iterate f (f x)
-}

-- Арифмитические последовательности
-- Последовательность от 1 до 10
arifmSequence1 = [1..10]
-- что то же самое, что и
arifmSequence1' = enumFromTo 1 10
-- Последовательность с шагом 2
arifmSequence2 = [1,3..10]
arifmSequence2' = enumFromThenTo 1 3 10
-- Можно генерировать и бесконечные списки
arifmSequence3 = [1..]
arifmSequence3' = enumFrom 1
-- Или с заданным шагом
arifmSequence4 = [1,3..]
arifmSequence4' = enumFromThen 1 3

-- Выделение списков, генераторы
-- Список квадратов чисел от 1 до 10
list4 = [x^2 | x <- [1..10]]

list5 = [x^2 | x <- [1..10], x^2 < 50]

list6 = [(x, y) | x <- [1,2], y <- [1,2]]

-------------------------------------------------------------------------------
-- Свертки
-------------------------------------------------------------------------------
-- Правая свертка
-- Пример: 1 'f' (2 'f' (3 'f' (... 'f' ini)))
{-
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f ini []     = ini
foldr f ini (x:xs) = x `f` foldr f ini xs
-}

-- Левая свертка
-- ((((ini 'f' 1) 'f' 2) 'f' 3) ...)
{-
foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f ini []     = ini
foldl f ini (x:xs) = foldl f (f ini x) xs
-}
-- Такую версию левой свертки обычно называют нестрогой. Ее минус в том,
-- что она создает большое отложенное вычисление вида f(f(f(...))).

-- Строгая версия левой свертки (из модуля Data.List)
{-
foldl' :: (b -> a -> b) -> b -> [a] -> b
foldl' f ini []     = ini
foldl' f ini (x:xs) = ini' `seq` foldl' f ini' xs
    where ini' = f ini x
-}

-- Правая свертка. Последний элемент списка является инициализирующим.
{-
foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 _ [x]    = x
foldr1 f (x:xs) = f x (foldr 1 f xs)
foldr1 _ []     = error "foldr1: EmptyList"
-}

-- Левая свертка. Первый элемент списка является инициализирующим.
{-
foldl1 :: (Ord a) => [a] -> a
foldl1 f (x:xs) = foldl f x xs
foldl1 _ [] = error "foldl1: EmptyList"
-}

-- snanl - левая свертка со всеми промежуточными значениями (from Data.List)
{-
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl f ini []     = [ini]
scanl f ini (x:xs) = ini : scanl f (ini 'f' x) xs
-}

-- scanr - правая свертка с промежуточными значениями
{-
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr _ ini []      = [ini]
scanr f ini (x:xs) = (x 'f' q) : qs
                     where qs@(q:_) = scanr f ini xs
-}

-- unfold - генерация списка на основе значения
{-
unfold :: (b -> (a,b)) -> b -> [a]
unfold f ini = let (x, ini') = f ini in
    x : unfold f ini'
-}

-- Тип данных Maybe
-- find :: (a -> Bool) -> [a] -> Maybe a
found = find odd [0, 2, 4]  -- = Nothing

-- unfoldr
{-
unfoldr (b -> Maybe (a, b)) -> b -> [a]
unfoldr f ini = helper (f ini) where
    helper (Just (x,ini')) = x : unfoldr f ini'
    helper Nothing         = []
-}

